* [[file:./../main-flow.org][Data Relational Mapping]]

* Sql Dictionary Generation

** TODO All this assumes selects simplicity sake in the short term.

   My suspicion is maps will be flexible enough to make insert/delete work. Perhaps a type on the query map somewhere.
   It would be nice to allow a select and an insert in a single sql query map. Graphql doesn't, though. Probably due
   to potential inconsistency issues. I'm inclined to leave those up to the developer. Maybe that is shitty.

** Rules and assumptions

   * Query dicts must adhere to their rules and assumptions
   * Models being queried must be registered
   * Queries may not request fields that aren't registered to a model
   * Multiple models may exist at the top level in a query map

** Flow

   Assume all steps are fail fast unless otherwise noted

   [[file:./../queries/queries.org::*Examples][Sample query]]

   1. Verify the model has been registered
   2. Validate that all the fields are found on the model
   3. Call the validators for each field
   4. Call the model validator
   5. Walk the fields calling the types to prepare their needs
      1. The prep fns will be passed:
	 1. Their field from the model
	 2. Their field from the query
	 3. ?
   6. The above should result in a map like
      #+BEGIN_SRC python
        {
            "select": [{
                "model": "myModel",
                "fields": [
                    "id",
                    "created",
                    {
                        "select": {[
                            "model": "user",
                            "fields": ["id", "name"]
                        ]},
                        "join": [{
                            "model": "user",
                            "on": {
                                "myModel": "user-id",
                                "user": "id"
                                # TODO: this means I need to fix the query structure. Oops
                            }
                        }]
                    }
                ]
            }],
                
      #+END_SRC
   7. This map needs to be reduced into the map below. Then it is ready to be serialized into a sql query.
      #+BEGIN_SRC python
        {
            "select": [
                {
                    "model": "myModel",
                    "fields": ["id", "created"]
                },
                {
                    "model": "users",
                    "fields": ["id", "name"]
                }
            ],
            "join": [{
                "model": "users",
                "on": {
                    "myModel": "user-id", "users": "id"
                }
            }]
        }

      #+END_SRC

** Verify registration
   
   Verifying registration is a matter of checking for the model's name in the registry's keys.

   #+BEGIN_SRC python :tangle dict_generator.py
     def verify_model_registered(registry, model):
         return model in registry
   #+END_SRC

   However, to make queries composable this logic needs to be applied to all top level keys in the query.

   #+BEGIN_SRC python :tangle dict_generator.py
     def verify_models_registered(registry, query):
         for model in query.keys():
             if not verify_model_registered(registry, model):
                 return False

         return True
   #+END_SRC

*** TODO Write tests at this level, too. It will help to describe the code and the tools can put the tests in the right places

** TODO Validate fields

   This seems like a simple walk over the query and check in the fields.

** TODO Call validators

   Another loop, I think. However, I'll need to account for increasing depths.

** TODO Call the types for query prep

   This will involve checking the actual data type in the query to determine if args are passed or not.
   In either case there should be a standard format that the type fns can get.

** TODO Reduce map
