* [[file:main-flow.org][Data Relational Mapping]]

* Model Definitions

** Rules and assumptions

   * A model's definition must only depend on the field types and any validators. These constraints should prevent any need for circular dependancies in the models themselves.
   * A type (or fn) that implements a known interface is used as the `:type` value. This allows custom type behavior (like implementing new relationships or serializing types
     to something suitable for the database). (N.B.: Types may require an interface or map of fns to implement a default validator/options selector)
   * Each field may have only one validator function that receives the value of that field.
   * Each model may have only one validator function that receives the values of the model.
   * Validators do not mutate or transform. They only approve or deny values.
   * Models must be registered in some way so the DRM can find the data.
   * A model may specify the behavior of it's fk children upon it's deletion (perhaps also on update?) via the chosen fk type.
   * A model's name must be unique

** Registering

   Registering only requires the user to pass the models to a fn as a list of models or a single models dict. The models are stored as a closure.
   It wouldn't be an issue to store the models in an object for persistance, but it would be no different to return an object w/ the data vs a closure.

   NB: Model registration is *not* additive

   Below is the format of the registry map. Users may provide models in this format.

   #+BEGIN_SRC python
     {
         "myModel": {
             "validator": tos_check,
             "fields": {
                 "id": {
                     "name": "id",
                     "type": Integer
                 }
                 "name": {
                     "name": "name",
                     "type": String,
                     "validator": max_length(100)
                 }
                 "user-id": {
                     "name": "user-id",
                     "type": OneToOne,
                     "model": "user",
                     "foreign-key": "id"
                 }
                 "tos": {
                     "name": "tos",
                     "type": Boolean
                 }
             }
         },
         #"users": {...}
     }
   #+END_SRC

   Registration is achieved by calling `models.register_models` with a list or dict of models. You will get an entrypoint to the query engine in response. This _should_ allow
   for isolated models if/when it is sensible to have them. (Models that can't be related to the drm because they're not in the same models dict)

   #+BEGIN_SRC python :tangle models.py
     from functools import singledispatch

     # this fn may not belong in here
     def __query_engine_factory(models):
         return lambda query_map: print(query_map)

     @singledispatch
     def register_models(models):
         raise Exception("query_engine_factory not implemented for {}".format(type(models)))

     @register_models.register(list)
     def register_models_list(models):
         model_dict = {}
         for model in models:
             # this seems like there must be a better, more pythonic way
             model_dict = {**model_dict, **model}

     @register_models.register(dict)
     def register_models_dict(models):
         return __query_engine_factory(models)
   #+END_SRC

** Examples

   #+BEGIN_SRC python
     from models import register_models

     myModel = {
         "model": "myModel",
         "validator": tos_check,
         "fields": {
             "id": {
                 "name": "id",
                 "type": Integer
             }
             "name": {
                 "name": "name",
                 "type": String,
                 "validator": max_length(100)
             }
             "user-id": {
                 "name": "user-id",
                 "type": OneToOne,
                 "model": "user",
                 "foreign-key": "id"
             }
             "tos": {
                 "name": "tos",
                 "type": Boolean
             }
         }
     }

     query_engine = register_models(myModel)
   #+END_SRC
